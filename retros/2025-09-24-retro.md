Retro: 2025-09-24

Summary
- Built a reproducible, high-fidelity “one-shot” landing page cloning workflow for arbitrary sites (e.g., YeshID, Okta).
- Separated time-to-clone from comparison time with a wrapper that measures only cloning and runs comparison afterward.
- Improved robustness for dynamic pages (cookie consent handling and auto-scroll to trigger lazy loads).
- Ensured clones render correctly by inlining CSS via ?raw in generated Landing.tsx, bypassing PostCSS parse errors.
- Verified structural parity with automatic compare artifacts (HTML, CSS, screenshot, structure JSON) and optional local compare.

What changed (infrastructure)
- scripts/clone.mjs
  - Landing.tsx template imports styles.css as raw string and injects via <style>.
  - Asset rewriting for src/href/poster mapped to local assetMap.
  - Cookie consent auto-accept and auto-scroll to load dynamic content.
- scripts/clone-compare.mjs
  - Comparison artifacts + structural summaries; analytics blocking; optional also-local capture.
  - Bounding boxes for interactive elements and simple diff summary.
- scripts/clone-site.mjs (new orchestrator)
  - Times only the cloning step; runs compare afterward.
  - Writes src/clones/<slug>/clone-run.json with timings and flags.
- package.json
  - Added npm run clone:site to invoke the orchestrator.
- App layout
  - Clone routes render without app chrome/padding for closer fidelity.

Measured times (latest)
- YeshID: 7.2s (clone-run.json)
- Okta: 9.0s (clone-run.json)

Key learnings
- PostCSS parse issues are common when concatenating external CSS; importing CSS as text and inlining avoids the toolchain entirely and improves reliability.
- Sites with heavy client rendering require interaction heuristics (accept cookies, auto-scroll) to capture all above-the-fold content.
- Each clone run previously overwrote clones/routes.ts, which hid earlier clones. For multi-site usage, aggregate routes from registry.json so each clone adds routes without removing existing ones.
- Blocking analytics and known trackers speeds up page stabilization and reduces noise in artifacts.
- Persisting a simple clone-run.json is helpful for tracking performance and diagnosing changes over time.

What worked well
- Inline CSS injection pattern (?raw + <style>) produced stable, pixel-credible results without dev server CSS errors.
- Orchestrator provided clean timing and automatic comparison without manual follow-up.
- Structural compare caught layout/landmark mismatches quickly and produced actionable notes.

What to improve next
- Route aggregation: Generate routes from src/clones/registry.json so multiple clones coexist automatically.
- More dynamic content heuristics: Optional tab/accordion click sampling and small viewport resize to trigger additional observers.
- ‘From-artifacts’ mode: Allow generator to seed from previously captured HTML/CSS to ensure deterministic output without network drift (useful for CI).
- CI check: Add a job to clone a known site, generate artifacts, and diff against a committed snapshot to detect regressions.
- Optional script allow/deny list during capture to reduce heavy third-party scripts that don’t affect visible content.

Decisions
- Infra changes merged to main. Feature branches and stashes removed to keep history clean. Current state supports one-shot cloning for new sites.

Action items (future)
- Implement route aggregation based on registry.json.
- Add optional interaction steps (“click first tab,” “expand first accordion”) behind a flag.
- Introduce a --from-artifacts flag to clone.mjs and corresponding storage conventions.
- Add CI pipeline step for snapshot-diff on a fixed target site.
